# TIL

## 오늘 공부한 컨셉

## 상세내용
concurrency와 parallelism은 다르다.

`` 동시성은 코드의 속성이고 병렬 처리는 실행 중인 프로그램의 속성이다.``

프로그램의 두 부분을 병렬로 실행하려는 의도로 코드를 작성하는 경우, 프로그램이 실행될 때 실제로 그렇게 되리라는 보장이 있는가? 코어가 하나뿐인 기기에서 해당 코드르르 실행하면 어떻게 될까? 누군가는 이 코드가 병렬적으로 실행될 것이라 생각하지만 실제로는 그렇지 않다. 실제로는 구별할 수 없을 정도로 빠르게 순차적으로 실행된다.
``두 개의 코어가 있는 시스템에서 동일한 바이너리를 실행하면 프로그램의 각 부분이 실제로 병렬로 실행중일 수 있다.``

### 코드 수준과 프로그램 수준에서 인지하기
1. 병렬적인 ``코드``를 작성하는 것이 아니라 병렬로 실행되기(그렇게 보이기)를 바라면서서 동시성 코드를 작성하는 것이다.
2. 동시성 코드가 실제로 병렬로 실행되는지 여부를 모를 수 있다.
3. 병렬 처리인지 아닌지는 시간, 컨텍스트에 의해 결정된다.
    - 여기서의 컨텍스트는 두 개 이상의 연산이 병렬적으로 실행됐다고 여길 수 있는 범위를 말한다.
    - 상황에 따른 컨텍스트의 정의가 중요한 이유는 **프로그램이 실행되는 프로세스, 프로세스의 운영체제의 스레드, 프로세스가 동작하는 장비 등으로 정의할 수 있기 때문**이다. atomic이 정의된 컨텍스트 내에서만 원자적이라 여길 수 있는 것처럼, 동시에 수행되는 작업은 정의된 컨텍스트에서만 정확하다. 컨텍스트는 상대적이다.

## CSP(Communicating Sequential Processes)
CSP는 상호작용하는 순차적 프로세스의 약자이자 논문 제목이다.
1978년에 찰스 안토니 리차드 호어가 이 논문을 공개했다.
호어는 ``프로그래밍에서 두 가지 기본 요소인 입력 및 출력이 간과되고 있으며, 특히 동시에 실행되는 코드의 경우에는 더욱 그렇다.``고 말한다.  호어가 이 논문을 집필할 당시에 프로그램을 구조화하는 방법에 대한 연구는 진행중이었다.
연구들 중 대부분은 순차적인 코드를 위한 기법에 관한 것이었다. 당시에는 goto 문법의 사용이 논의되고 있었고 객체지향 패러다임이 싹트기 시작했다.

> 1960년대 앨런 케이는 객체지향 아이디어를 생각해냈다. 
    https://velog.io/@eddy_song/alan-kay-OOP?fbclid=IwAR3lggAxUYNq0zDbs0BB-m2Lhsn8i7U66UUZ2HQCNayvvG-KY6oWnrPjt8c

동시성 연산에 대해서는 크게 고려하지 않았다. 호어가 이를 바로잡기 위해서 그의 논문과 CSP가 탄생하게 된 것이다.
CSP는 상호작용하려는 순차적 프로세스들의 능력을 입증하려는 목적으로 만들어진 단순한 프로그래밍 언어였다.
이후에 6년 동안, CSP의 개념은 상호작용하는 순차적 프로세스들이라는 개념과 결합해서 프로그램의 정확성을 입증하는 연구를 통해 프로세스 미적분/대수(process calculus/process algebras)라는 형식 표현법(format representation)으로 발전했다. 
- 프로세스 미적분: 동시성 시스템을 수학적으로 모델링 하는 방법으로 시스템들을 대상으로 여러가지 변형을 수행해 효율성 및 정확성과 같은 다양한 속성을 분석하는 대수적 법칙을 제공

CSP에 대한 최초 논문과 그로부터 진화된 언어가 Go의 동시성 모델에 크게 영감을 주었다.

호어는 입력과 출력이 언어 기본 요소로 간두왜야 한다는 주장을 뒷받침하기 위해 CSP 프로그래밍 언어에 프로세스 간 입력 및 출력, 즉, 통신을 정확하게 모델링하기 위한 기본 요소들을 포함시켰다. 호어의 논문 제목(CSP)가 이 통신에서 유래했다.

호어는 입력을 요구하고 다른 프로세스가 사용할 출력을 생산하는 로직의 캡슐화된 부분을 ``프로세스``라고 지칭했다. 호어가 논문을 집필할 당시에 업계에서 프로그램을 어떻게 구조화할 것인지에 대한 논쟁이 없었다면 ``프로세스`` 대신 ``함수``라는 용어를 사용했을지도 모른다. 

호어는 프로세스 사이의 통신을 위해 입력 및 출력 명령을 만들었다. 
+ !는 프로세스 입력을 보내기 위함
+ ?는 프로세스 출력을 읽어오기 위함
+ 각 명령은 프로세스의 바깥에서 변수를 읽는 경우와 출력 변수를 프로세스로 입력을 보내는 경우는 목적지를 지정해야함.
  + 위 두 가지가 동일한 것을 가리키는 경우는 두 프로세스가 상응(correspond)한다고 말한다. 
  + 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달되는 경우가 이에 해당한다.

CSP 논문에서 가져온 몇 가지 예제

|연산|설명|
|:-------:|:------------------:|
|cardreader?cardimage|cardreader로부터 card를 읽어와서 그 값(문자열)을 cardimage 변수에 할당한다.
|lineprinter!lineimage|lineprinter에 출력을 위한 lineimage 값을 전송한다.
|X?(x,y)|X라는 이름을 가지는 프로세스에서 한 쌍의 값을 입력 받아 x와 y에 할당한다.
|DIV!(3*a+b, 13)|DIV 프로세스에게 두 개의 지정된 값을 출력한다.
|*[c:chracter;west?c -> east!c]|west에서 출력된 모든 문자열을 읽어와서 그것들을 하나씩 east로 출력한다. west 프로세스가 종료되면 이 반복을 중단한다.

위 예제는 누가봐도 Go 채널과 유사하다는 걸 알 수 있다. 마지막 west-east 예시는 두 프로세는 상응(correspond)하는 프로세스다. 

역사는 호어의 제안이 정확하다고 판단했다. 그러나 Go가 발표되기 전까지는 극소수의 언어들만 이러한 기본 요소를 언어 내적으로 지원했다는 점은 흥미롭다. 인기 있는 언어의 대다수는 CSP의 메시지 전달 스타일보다 메모리에 대한 접근을 공유하고 동기화하는 방식을 선호한다. 
**Go는 CSP의 핵심 원칙을 통합한 최초의 언어 중 하나로, 동시성 프로그래밍 스타일을 대중에게 제공한다.**

특정 상황에서는 메모리를 공유하는 것이 더 적절하지만 공유 메모리 모델은 대규모 프로그램이나 복잡한 프로그램에서 올바르게 활용하기 어려울 수 있다. 동시성이 Go의 강점 중 하나로 간주되는 이유가 바로 이것이다. 처음부터 CSP 원칙을 염두에 두고 구축됐으므로 읽고 쓰기 쉽고 추론하기 쉽다.

## 동시성을 지원하는 언어의 장점
Go가 동시성과 관련해 다른 대중적인 언어와 차별화되는 점은 무엇일까?

+ 많은 언어는 보통 OS 스레드 및 메모리 접근 동기화 수준에서 언어의 추성화 체인을 끝낸다.
+ Go는 다른 방식을 사용해 고루틴 및 채널의 개념으로 이를 대체한다.

동시성 코드를 추상화하는 두 방법의 개념을 비교
+ 고루틴: 스레드와 비교
    - 고루틴은 병렬성 측면을 고민할 필요가 없도록 도와줌
+ 채널: 뮤텍스와 비교

## Go의 동시성에 대한 철학
Go의 많은 부분은 CSP를 중심으로 설계되었지만 메모리 접근 동기화를 비롯한 여러 가지 전통적인 동시성 코드 작성 방법 역시 지원함

sync 및 기타 패키지들의 구조체와 메서드를 사용하면 잠금을 수행하고 리소스 풀을 만들고 고루틴을 선점하는 등의 작업을 할 수 있다. sync 패키지는 mutual exclusion lock 같은 기초적인 동기화 기본 요소를 제공함. Once와 WaitGroup 타입을 제외하면 대부분 저수준 라이브러리 루틴에서 사용하기 위한 것. 채널 및 통신을 통해 보다 높은 수준(추상화)의 동기화를 수행할 수 있음.

> Go의 모토 중 하나는 "통신을 통해 메모리를 공유하고 메모리 공유를 통해 통신하지 말라"이다. 대부분의 잠금 문제는 채널이나 전통적인 잠금(뮤텍스)중 하나를 사용해서 해결할 수 있다.

### 채널을 사용하는 경우와 메모리 동기화를 사용해야 되는 경우
잠금 문제를 해결하기 위해서 둘 중 어느것을 골라야 하냐면 **가장 표현력이 풍부하면서 가장 단순한 것, 또는 둘 중에 하나에 해당하는 것**을 사용하면 된다.
위 명제를 따지기 위한 결정 트리가 있다.

+ 채널을 사용하면 안되는 경우
  - 성능상의 임계 영역일 때
  - 구조체 내부 상태를 보호해야 하는 상황
+ 채널을 사용하는 경우
  + 데이터 소유권을 이전하려는 경우
  + 여러 부분의 논리를 조정해야 하는 경우
  
동시성에 대한 Go의 철학은 다음과 같이 요약할 수 있다. **단순화를 목표로 하고, 가능하면 채널을 사용하며, 고루틴을 무한정 쓸 수 있는 자원처럼 다루어라**

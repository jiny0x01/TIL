# TIL

## 오늘 공부한 컨셉
Go 동시성 concurrency in go

## 상세내용

+ 무어의 법칙
  - 전자공학 시장이 집적 회로로 통합될 것이며 집적 회로 구성 요소가 2년마다 두 배가 될 것이라는 법칙
  - 2012년까지 대강 맞음
+ 암달의 법칙
  - 문제의 해결책을 병렬적으로 구현하면 잠재적으로 성능이 얼마나 향상될지 모델링하는 방법
    - 프로그램에서 순차적인 방식으로 작성할 수 밖에 없는 부분이 얼마나 되는지에 따라 성능 향상의 한계가 있음
    - 최대한 많은 부분을 병렬적으로 실행하면 성능이 좋아지겠지?
+ 과잉 병렬(embarrassingly parallel)
  - 손쉽게 병렬 작업들로 나눌 수 있음을 의미
  - 예를 들면 파이의 자릿수를 계산하는 스피곳 알고리즘
  - 과잉 병렬에 해당할 경우 **프로그램에서 더 많은 코어를 사용할 수 있게 만들어 성능을 향상할 수 있다.**
    - 병렬 처리된 결과를 어떻게 결합하고 저장하느냐가 새로운 문제로 떠오름
    - 수평적으로 확장할 수 있는 애플리케이션을 작성하면 됨 
        - 수평확장 가능 -> 더 많은 CPU나 기기에서 실행 가능하다는 의미(클라우드 컴퓨팅)

### web scale
어떤 소프트웨어가 웹 스케일이면 이 소프트웨어는 과잉 병렬일 것이라 예상 가능
웹 스케일 소프트웨어는 일반적으로 애플리케이션의 인스턴스들을 추가하여 동시에 많은 부하를 처리
- 롤링 업그레이드
- 수평 확장 가능한 아키텍처
- 지리적 분산(대륙마다 리전을 설치하는 것을 의미하나봄)


## race condition
둘 이상의 작업이 올바른 순서로 실행돼야 하지만 순서가 보장되지 않을 때 발생
+ 작업A가 변수를 읽을 때 작업B도 동일한 변수를 읽으려고 함 (서로 읽으려고 경쟁)
+ 작업 A/B에 의해 변수 값이 올바르게 보장되지 않음

## atomic과 context
atomic을 생각할 때 가장 먼저 해야하는 일은 연산이 원자적인 것으로 간주해야 할 컨텍스트 또는 범위(scope)를 정의하는 것이 중요

## indivisible과 uninterruptible
사용자가 정의한 컨텍스트 내부에서 원자적인 요소가 통째로 발생하며, 해당 컨텍스트 내에서는 해당 요소 외에 어떤 것도 동시에 이루어지지 않는 다는 것을 의미

> i++

위 예제는 원자적으로 보이지만 사실은 3가지 연산으로 구성 되어 있음
+ i의 값을 가져온다.
+ i의 값을 증가한다.
+ i의 값을 저장한다.

각 연산은 원자적이지만, 세 연산의 조합은 컨텍스트에 따라 원자적이지 않을 수 있다.
**원자적 연산을 조합한다고 반드시 더 큰 범위의 원자적 연산이 생성되는 건 아님**.
동시에 수행되는 프로세스들이 없는 프로그램의 컨텍스트라면 ``i++`` 연산은 해당 컨텍스트 내에선 원자적임. 

원자성이 중요한 이유는 **암묵적으로 동시에 실행되는 컨텍스트들 내 에서는 안전함을 의미**하기 때문

## 임계 영역 설정의 의문 2가지
뮤텍스로 임계영역에 들어가고 나올 때 lock()과 unlock()을 하게 되면 설정한 구간에서는 원자성을 보장할 수 있다.
이러한 연산을 수행할 때마다 프로그램은 일정 시간동안 멈춘다. 여기서 2가지 의문이 제기된다.
1. 임계 영역에 반복적으로 들어갔다 나오는가?
2. 임계 영역은 어느 정도 크기여야 하는가?

이 질문에 정답은 없기 때문에 메모리 접근 동기화가 어려운 영역이다.

## Deadlock
데드락을 탐지, 예방 및 교정하는 방법으로 코프먼 조건이 있다.
+ 상호 배제(mutual exclusion)
  + 동시에 실행되는 프로세스가 어떤 임의의 시점에 하나의 리소스에 대해 배타적 권리를 보유
+ 대기 조건(Wait for condition)
  + 동시에 실행되는 프로세스는 하나의 리소스를 보유하고 있는 동시에ㄷ또 다른 추가 리소스를 기다리고 있다.
+ 비선점(No preemption)
  + 동시에 실행되는 프로세스 중 하나를 보유하고 있는 리소스는 해당 프로세스에 의해서만 사용 해제될 수 있다.
+ 순환 대기(Circular Wait)
  + 동시에 실행되는 프로세스 중 하나가 다른 프로세스로 이어지는 체인에서 기다려야 한다.

**위 조건들 중 하나라도 참이 아니라면 데드락이 발생하는 것을 막을 수 있다.**

## Livelock
프로그램들이 활동적으로 동시에 연산을 수행하고 있지만, 이 연산들이 실제 프로그램의 상태를 진행시키는데 아무런 영향이 없는 연산을 의미
예를 들면 복도에서 다른 사람을 향해 걷는데 A가 지나갈 수 있도록 B가 비켜주었지만 A가 같은쪽으로 비켜서고 B가 다시 비켜서줬지만 A가 B를 따라 반대편으로 이동하면 둘은 평생 지나갈 수 없게 된다.

라이브락은 기아상태의 부분 집합에 속하는 문제이다.

## 기아상태와 메모리 접근 사용의 균형 잡기
동기화된 메모리 접근에는 비용이 많이 든다. 따라서 임계영역 너머까지 잠금을 확장하는 것이 유리할 수 있다. 하지만 동시에 다른 프로세스를 기아 상태에 빠뜨릴 위험이 있다. 따라서 **성능을 위해 큰 범위에서 동기화할지, 공정성을 위해 세분화된 범위에서 동기화를 수행할지 균형점을 찾아야한다.** 애플리케이션의 성능을 조정해야 할 때가 되면 우선 임계영역에서만 메모리 접근을 동기화하도록 제한할 것을 추천한다. 

**동기화가 성능에 문제를 일으키는 경우(빈번한 lock으로 성능저하)에는 언제든 범위를 확장할 수 있지만 반대로 줄이는 것은 어렵다.**

기아 상태는 CPU, 메모리, 파일 핸들, 데이터베이스 연결에도 적용될 수 있음을 염두하자. 공유할 수 있는 리소스 모두 기아 상태에 빠질 수 있다.

## 동시성 코드를 안전하게 작성하기 위한 노력
주석을 달자
+ 누가 동시성을 책임지는가?
+ 문제 공간은 동시성 기본 요소에 어떻게 매핑 되는가?
+ 동기화는 누가 담당하는가?

```
// CalculatePi 함수는 시작(begin)과 끝(end) 사이에 자릿수를 계산한다.
func CalculatePi(begin, end int64, pi *PI)
```

```
// CalculatePi 함수는 시작(begin)과 끝(end) 사이에 자릿수를 계산한다.
// 내부적으로, CalculatePi는 CalculatePi를 재귀 호출하는 FLOOR((end-begin)/2) 개의 동시 프로세스를 생성할 것이다. (FLOOR가 동시성 책임)
// pi 변수에 쓰는 작업에 대한 동기화는 Pi 구조체 내부에서 처리한다. (동기화 담당)
func CalculatePi(begin, end int64, pi *PI)
```
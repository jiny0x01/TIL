# TIL

## 오늘 공부한 컨셉
+ 응답시간과 지연시간
+ 응답시간 측정을 위한 백분위
+ SLA

## 상세내용
### 서비스 응답 시간
대부분의 요청은 꽤 빠르지만 가금 꽤 오래 걸리는 특이 값(outlier)이 있다. 

+ 일반적으로 평균보다는 백분위를 사용하는 편이 좋다.
+ 응답 시간 목록을 정렬하면 중간 지점이 중앙값이 된다.
+ 중앙값은 50분위로써(100개중에 50번째, 200개중에 100번째) **p50**으로 축약할 수 있다.(percentile: 백분위)
+ 중앙값은 단일 요청을 참고한다.
+ 사용자가 여러 개의 요청을 보내면(세션이 많거나 한 페이지에 여러 자원이 포함돼 있어서) 최소한 하나의 요청이 중앙값보다 느릴 확률이 50%보다 훨씬 높다.
+ 특이값이 얼마나 좋지 않은지 알아보려면 p95, p99, p99.9를 살펴보는 것이 일반적이다.
  + 95분위 응답 시간이 1.5초라면 100개의 요청중 95개는 1.5초 미만이고 5개는 1.5초보다 더 걸린다.

### tail latency(꼬리 지연시간)
tail latency로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.
+ 아마존은 내부 서비스의 응답 시간 요구사항을 99.9분위로 기술한다.
  + 요청 1000개중 1개만 영향이 있는 수준
+ **보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 갖고 있다.**
  + 이는 가장 귀중한 데이터이자 고객이다.
+ 99.99분위를 최적화하는 작업에는 비용이 너무 많이 들어서 아마존에서 추구하는 목표에 충분히 이익을 가져다주지 못한다고 여겨진다.

### SLO(Service level objective)와 SLA(Service level agreement)
백분위는 SLO와 SLA에서 자주 사용된다.
+ SLO(서비스 수준 목표)
+ SLA(서비스 수준 협약서)
    + 예시:``응답 시간 중앙값이 200밀리초 미만이고 99분위가 1초 미만인 경우(응답 시간이 길면 서비스가 종료될 수도 있다) 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.`` 이런 지표는 서비스 클라이언트의 기대치를 설정해 서비스 수준 협약서를 지키지 못하면 고객이 환불을 요구할 수 있게 한다.

### queueing delay
큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다. 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청처리만으로 후속 요청 처리가 지체된다. 이 현상을 선두 차단(head-of-line blocking)이라고 한다.

서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각할 것이다. 이런 문제 때문에 클라이언트쪽 응답 시간 측정이 중요하다.

### 실전 백분위
작은 비율의 벡엔드 호출만 느려도 최종 사용자 요청이 여러 번 백엔드를 호출하면 느린 호출이 발생할 가능성이 증가한다. 그래서 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려진다. 이 효과를 꼬리 지연 증폭이라 한다.

서비스의 모니터링 대시보드에 응답 시간 백분위를 추가하려면 지속적으로 백분위를 효율적으로 계산할 필요가 있다.
예를 들어, 지난 10분간 요청의 응답 시간을 rolling window(이동 평균선 정도로 이해)로 유지하고 싶다면 1분마다 구간 내 중앙값과 다양한 백분위를 계산해 각 지표를 그래프에 그리면 된다.

단순한 구현으로 시간 구간 내 모든 요청의 응답 시간 목록을 유지하고 1분마다 목록을 정렬하는 방법이 있다.

상황에 따라서 forward decay나 T-digest, Hdr히스토그램같은 CPU와 메모리 비용을 최소화 하면서 좋은 백분위 근사치를 계산할 수 있는 알고리즘이 있다. 

백분위 평균(시간 해상도 줄이기, 여러 장비의 데이터 결합)은 수학적으로 의미 없으니 주의. **응답 시간 데이터를 집계하는 올바른 방법은 히스토그램을 추가하는 것**이다. 
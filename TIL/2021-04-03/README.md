# TIL

## 오늘 공부한 컨셉

+ 클라우드 네이티브 아키텍처와 전통적인 아키텍처의 차이점

+ 클라우드 네이티브는 이벤트 주도 아키텍처를 가짐

+ service choreography(코레오그래피)

  + 각 서비스는 독립적으로 동작하며 자신의 상태를 관리함

+ API Versioning

  + 매듭
  + point to point
  + compatible versioning

+ REST API 접근법 세가지

  + global versioning
  + resource versioning
  + mine-based versioning

+ semantic versioning

  + 메이저/마이너/패치 버전

+ 메시지 프로토콜

  + MQTT(message queue telemetry transport)
  + AMQP(Advanced Message Queuing protocol)
  + 가벼운건 MQTT, 상호운용성은 AMQP

+ pub/sub 패턴

+ 게이트웨이

  

## 상세내용



## 클라우드 네이티브 vs 전통적인 아키텍처

기본적인 차이점 중 하나로 세션, 설정 데이터 관리가 있다

+ 전통적인 아키텍처에서는 상태가 있다. 

  + 로드밸런서는 사용자 요청이 항상 동일한 서버 인스턴스에 도달하기 위해 sticky session을 사용한다
  + 전통적인 애플리케이션은 사용자 프로필 정보 같은 유저 정보를 외부 데이터스토어에서 검색해 세션 변수로 저장하는게 흔한 방법
  + 특정 유저의 모든 트래픽을 항상 같은 인스턴스로 보내는 일은 로드밸런서의 몫
  + vm의 상태가 맛탱이 가면 로드밸런서는 다른 vm에 트래픽을 전달해야함
    + state를 1번 vm에 저장했는데 1번 vm이 뻗으면?
    + 로드밸런서는 2번 vm으로 보내지만 2번 vm에는 state가 없으므로 상태 불일치가 됨

+ 클라우드 네이티브 애플리케이션은 그러한 상태가 없음

  + 상태가 없다는건 데이터 때문에 UX에 영향을 주지 않고 컴퓨터 인스턴스를 동적으로 조절할 수 있다는 것

  + 로드밸런서가 인스턴스에 요청을 할당해도 인스턴스들은 외부 저장소에 상태를 저장하면 됨.

    > scale in 할 때 해당 인스턴스의 커넥션을 모두 정리해야함



모놀리식 애플리케이션은 서로 다른 구성 요소를 통합하는 기술로 대부분 **서비스 오케스트레이션을 사용**

서비스 오케스트레이션을 **쿠버네티스상의 컨테이너 오케스트레이션**과 헷갈리면 안됨

서비스 오케스트레이션은 여러 구성 요소나 서비스가 하나처럼 작동하도록 조정하는 기술

+ 예시
  1. 클라이언트가 애플리케이션에 요청. 로드밸런서는 서비스 A에 전달
  2. 서비스 A는 서비스 B, 서비스 C에 요청을 전달하고 대기
  3. 서비스B, 서비스C로부터 응답받으면 서비스 A는 응답을 클라이언트에 전송



클라우드 네이티브 애플리케이션은 커뮤니케이션으로 이벤트 주도 패턴을 흔히 사용

**서비스 코레오그래피(service choreography)**

+ 느슨하게 결합된 서비스 간의 요청을 조절
+ 각 서비스는 격리되고 자율적이고 자신의 상태를 관리할 권한이 있음
+ 예시
  1. 클라이언트가 요청 보냄. 로드밸런서는 서비스 A에게 전달
  2. 서비스B는 독립적으로 동작하고 자신의 데이터를 이벤팅 시스템에 전송
  3. 서비스C는 독립적으로 동작하고 자신의 데이터를 이벤팅 시스템에 전송
  4. 서비스A는 이벤트 시스템에서 데이터를 가져와 클라이언트에 전송



장애 처리 방식

+ 전통적인 애플리케이션
  + 데이터베이스 클러스터링
+ 클라우드 네이티브 애플리케이션
  + 장애가 있을 것이라 예상하고 장애를 처리하는 방식



## 함수vs서비스

### 함수

함수가 잘 어울리는 시나리오

+ 상호작용할 필요 없는 단순 병렬 실행 시나리오
  + 아티팩트 생성
  + 레코드 업데이트
  + map-reduce 함수
  + 배치 처리
+ IoT에서 작업 조정할 때
+ FaaS 오퍼링을 이용해서 개발되었을때 애플리케이션이 장기간 실행하는 작업을 조정하는 것을 도와줌



함수 이용시 고려할 점

+ 모놀리스에서 마이크로서비스로 전환 시 과제
  + 네트워크 통신 복잡도
+ 함수의 제한된 수명
  + FaaS 오퍼링은 함수의 실행 시간을 제한함 -> 장시간 작업에 부적합
+ 특수 하드웨어 사용 불가능
  + GPU 같은 하드웨어를 사용할 수 있도록 제공하는 클라우드는 없음
+ 함수는 상태가 없음. 네트워크로 직접 접근 불가능
  + FaaS는 이벤트 주도 분산 프로그래밍 모델이나 프런트 함수용으로 API 관리 솔루션 써라
  + 함수들은 데이터를 이벤팅이나 메시지 시스템으로 전달해 함께 작동함
  + 대형 애플리케이션 전체를 함수로 개발하면 모든 통신과 데이터 처리를 네트워크로 해야함 -> 성능하락
+ 로컬 개발과 디버깅
  + FaaS 런타임중 일부는 이식성이 없음
+ 경제성
  + FaaS 오퍼링은 실행 시간에 과금함
  + 비용 예상은 매우매우매우 어려움



### 함수와 서비스의 조합

컨테이너화된 서비스의 유연함과 FaaS의 단순성의 장점을 둘 다 가져갈 수 있음

투표앱을 예시로 보자. 아래는 이벤트 소싱 패턴이다.

1. 투표 앱 컨테이너가 있고
2. 투표를 제출하면 메시지는 이벤팅 시스템에 들어감
3. 이벤팅 시스템에서 데이터스토어에 데이터를 추가하는 함수를 실행
4. 결과는 데이터스토어에서 데이터를 읽어서 결과 컨테이너앱에 보여줌

데이터스토어에 데이터를 추가하는 로직을 함수로 구현하면 애플리케이션은 필요할 때 쉽게 확장할 수 있음 + 경제적



## API 설계와 versioning

API versioning 전략 3가지

1. 매듭
   + API를 사용하는 고객은 버전 하나만 사용
   + 새로운 API 버전이 나올 때 마다 강제로 업그레이드 -> 고객에게 가장 비싼 접근법
2. point to point
   + 모든 API 버전 제공
   + 고객은 필요한 API 버전 사용. 개발자는 유지보수 -> 개발자에게 비싼 접근법
3. 버전 호환(compatible versioning)
   + 모든 고객이 동일한 API 버전사용
   + 최신버전이 하위 호환성을 유지하는 전략

버전 호환이 가장 효율이 좋음. 하위 호환성을 위해 더 많은 작업을 하긴 해야함



### REST의 versioning 접근법 3가지

+ global versioning
  + 전체 API버전 설정
  + 버전의 경로의 일부로 지정(e.g : /api/v1/users)
  + 하위 도메인의 일부로 지정(e.g : api-v1.example.com/users)
+ resource versioning
  + 세부적으로 버전 관리
  + /api/v2/users는 버전2지만
  + /api/v1/tasks는 바꾸지 않고 둠
+ mine-based versioning
  + URL이나 도메인에 넣는 위 2가지 방법가 다르게 헤더에 넣음
  + API 엔드포인트를 깔끔하게 유지할 수 있지만 더 복잡할 수 있음



### API 하위와 상위 호환성

기존 서비스를 방가뜨리지 않고 업데이트하는지 확인

하위 호환성을 관리하기 위한 모범 사례

+ 새 API에 적합한 기본값 또는 선택 가능한 값을 제공
  + 불가능하면 새로운 자원을 만들어라
+ 기존 필드 이름을 변경/삭제 금지
+ 꼭 필요한 것을 선택사항으로 두지 마라
+ 더 이상 사용 안하면 예전 API 엔드포인트를 사용하지 않는다고 표시
+ 새 버전과 기존 버전의 서비스가 메시지들을 이용해 함께 잘 작동하는지 테스트

상위호환성: 서비스가 최신 버전용 요청을 받아서 잘 처리할 수 있다는 것을 의미

일반적인 방법으로 추가 필드가 생기더라도 무시하고 오류를 보내지 않음



### semantic versioning

메이저/마이너/패치를 사용한 버전관리. 거의 표준임

+ 메이저 버전은 API 호환성이 변경됐을 때 올림
+ 마이너 버전은 하위 호환되는 기능을 추가됐을 때 올림
+ 패치 버전은 하위 호환되는 버그를 수정했을 때 올림



## 프로토콜

대부분 HTTP를 쓰지만 가장 성능 좋은건 아님

+ 웹소켓
  + 서버-클라이언트 실시간 통신 표준
  + 양방향으로 오래 살아있는 커넥션을 생성해서 작은 오버헤드로 데이터 전송

+ HTTP/2
  + 모든 HTTP를 대체하진 못함
  + 스트림을 이용한 하나의 TCP 커넥션을 통해 멀티플렉싱 요청을 짧은 지연으로 처리하도록 설계됨
  + HTTP/2는 바이너리 프로토콜임
  + HTTP1.x는 텍스처 프로토콜
  + 바이너리 프로토콜은 파싱할 때 유리함
+ gRPC



### 메시징 프로토콜

클라우드 네이티브 애플리케이션은 이벤트 주도/메시지 기반 접근법을 사용

+ MQTT(message queue telemetry transport)
  + IoT와 기계끼리 통신에 사용하는 바이너리 프로토콜
  + 네트워크 통신이 불안정하고 대역폭이 작은 환경용으로 설계됨
  + 센서와 게이트웨이간의 통신에 사용
  + 초경량 프로토콜
  + 전송을 보장함
+ AMQP(Advanced Message Queuing protocol)
  + 신뢰성 있는 큐, 토픽 기반 발행자와 구독자, 라우팅 보안, 트랜잭션 등 다양한 기능을 가진 메시징을 위해 설계됨
  + 따라서 경량/성능 프로토콜은 아님
  + 다양한 Vendor가 많은 테스트를 해서 신뢰성이 높음
  + 주 사용 이유: 서로 다른 벤더간 상호운용성 때문

두 프로토콜 모두 TCP를 통한 웹소켓과 함께 사용됨. 443 포트를 통한 HTTP만 사용하도록 제한된 환경에서 적합

간단+안정적 메시징 -> MQTT

상호운용성+기능성 -> AMQP



## 멱등성

여러 번 작업실행 해도 결과의 변화가 없는 것(e.g : set)

데이터를 보냈는데 네트워크 에러로 안갔으면?

- ID를 추가해서 동일한 메시지인지 따져봄. 
- 이를 de-duping이라함(중복제거)



비동기 통신 패턴에서는 멱등성을 어떻게 보장할까?

+ id를 주는 것 까진 ok. 비동기에선 응답할 때 큐를 만들어서 요청받은 ID를 큐에 넣어서 잘 받았다고 응답해줌



## 발행자와 구독자

비동기 통신을 촉진하기 위한 가장 일반적인 패턴

발행자가 토픽에 메시지를 발행하면 해당 토픽을 구독하고 있는 모든 구독자가 그 메시지를 가져감

pub/sub은 크게 2가지 시나리오가 있음

+ 발행자와 구독자가 분리되어 있어서 서비스와 함수가 느슨하게 커플링됨
+ 이벤트 기반 설계가 가능함

비동기 환경이라는걸 상기!

1. 서비스 A는 토픽에 메시지를 발행
2. 메시징 브로커는 해당 토픽을 구독하고 있는 모든 구독자에게 알림
3. 구독자들이 메시지를 가져감(? 가져가는건지 브로커가 주는건지 모르겠음)

주의사항

+ 메시지의 순서가 보장이 안되니 멱등성을 보장해줘야함
+ state가 있는 애플리케이션은 메시지의 순서가 중요함. 메시징 시스템에 내장된 정렬 기능을 활용하거나 우선순위 큐를 적용
+ 메시지 처리 결과가 잘못되면 메시지를 반환하지 않고 에러 메시지 처리 큐에 넣어라



#### pub/sub은 메시징의 핵심

메시지 큐의 차이는?

+ 메시지 큐는 각 메시지를 하나의 소비자가 오직 한번만 처리(1:1)
+ pub/sub 메시징은 여러 개의 수신자가 하나의 토픽을 구독해서 메시지 처리(1:N)
  + 따라서 수신자를 늘리면 처리율이 올라감



### 동기 vs 비동기

동기를 사용할 때 기억해야할 점

+ 자원 소진 : 동기는 스레드 블록한다는 의미
+ 응답 지연 
+ 연쇄 장애

클라우드 네이티브에서는 이벤트와 큐 기반의 비동기 메시징이 IPC(interprocess communication)용으로 가장 인기있다.



## 게이트웨이

+ API 게이트웨이
  + 클라이언트와 서비스 사이에 둠
  + 비즈니스 API를 노출하거나
  + SSL 처리 / 인증 처리 등
+ 애플리케이션 게이트웨이
  + 주로 SSL, offloading, 정적 자원 라우팅, 오브젝트 스토리지로 라우팅하는데 사용



## 라우팅

게이트웨이의 가장 일반적인 기능

리버스 프록시 : 사설 내트워크 내부에 있으면서 클라이언트에서 들어오는 요청을 백엔드 서비스로 전달하는 역할

+ 클라이언트가 하나의 엔드포인트와 통신이 필요할 때 유용
+ 운영 비용과 게이트웨이 관리를 고려해야한다.
  + 여러 서비스를 추상해서 병목이 될 수 있고 
  + 게이트웨이에서 부하가 발생하면 확장할 수 있어야함
  + 아니면 관리형 게이트웨이 서비스를 쓰던지

> aggregator : 여러 정보를 한군대로 모아 전달해주는 역할



## Aggregation

게이트웨이를 에그리게이터로 쓸 수 있다.

1. 클라이언트가 요청하면 게이트웨이는 각 서비스나 함수로 요청 여러개를 보냄
2. 서비스는 요청을 받고 응답을 보냄
3. 게이트웨이는 응답을 취합해서 클라이언트에게 전송



+ 장점
  + 클라이언트는 엔드포인트를 여러 곳에 요청하지 않아도 됨
  + 트래픽이 줄어듬
+ 단점
  + 부하가 추가됨
  + 모놀리스가 될 수 있음

게이트웨이 부하 때문에 다운되면 에그리게이션을 분리하거나 배치 서비스를 도입하셈

> batch: 일괄적으로 한번에 처리하여 응답을 보냄
>
> 예를 들면, 새벽 시간엔 사람이 자니까 응답을 다 보내줄 필요없고 아침에 모아서 싹 처리하면 됨

게이트웨이에서 에그리게이션 로직을 빼면 부하가 줄어듬. 따라서

``클라이언트 - 게이트웨이 - 에그리게이션 서비스 - 서비스들`` 구조로 나누는게 좋음



## 오프로딩 Offloading(짐을 내리다 -> 서비스의 기능을 분리)

게이트웨이의 일반적인 사용 방법

+ 개벌 서비스에서 기능을 분리해서 게이트웨이 수준에서 처리하는 것
+ 개별 서비스에서 SSL 처리하지 않고 게이트웨이에서 처리함

오프로딩은 모든 서비스에서 사용할 수 있는 기능만 게이트웨이로 분리하는 것을 말함

+ 인증과 권한
+ 비율 제한, 재시도 정책, 서킷 브레이킹
+ 캐시
+ 압축
+ SSL 오프로딩
+ 로깅과 모니터링

**게이트웨이에서 많은 기능을 오프로드할 수록 성능이 떨어짐**



### ingress vs egress

ingress는 외부에서 안으로 요청을 들어오는거

egress는 내부에서 외부로 요청을 보내는 것

외부 서비스에 접근 시 모니터링이나 제어가 필요하면 egress 게이트웨이를 사용해라

